import { supabase } from './supabaseClient';
import { toast } from '@/hooks/use-toast';

// Tipos
export interface User {
  id: string;
  email: string;
  role: 'admin' | 'leader' | 'user';
  username?: string;
  display_name?: string;
  first_name?: string;
  phone_number?: string;
  bio?: string;
  avatar_url?: string;
  created_at?: string;
  profile_views?: number;
}

/**
 * Realiza o login do usu√°rio com email e senha
 * Sistema simplificado que apenas verifica credenciais e busca o perfil
 */
export async function signInWithEmail(email: string, password: string): Promise<User | null> {
  try {
    // 1. Autenticar com Supabase
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });
    
    if (error) {
      toast({
        title: "Erro no login",
        description: "Email ou senha incorretos",
        variant: "destructive"
      });
      return null;
    }
    
    const userId = data.user.id;
    
    // 2. Buscar perfil na tabela uuid
    const { data: profile, error: profileError } = await supabase
      .from("uuid")
      .select("*")
      .eq("id", userId)
      .single();
    
    if (profileError) {
      toast({
        title: "Erro ao buscar perfil",
        description: "N√£o foi poss√≠vel recuperar seus dados",
        variant: "destructive"
      });
      return null;
    }
    
    // 3. Armazenar para acesso r√°pido
    localStorage.setItem('current_user', JSON.stringify(profile));
    
    return profile as User;
  } catch (error) {
    toast({
      title: "Erro no login",
      description: "Ocorreu um erro inesperado",
      variant: "destructive"
    });
    return null;
  }
}

/**
 * Registra um novo usu√°rio com email e senha
 * Sistema simplificado que apenas registra no auth e na tabela uuid
 */
export async function signUpWithEmail(
  email: string, 
  password: string, 
  firstName: string, 
  phoneNumber: string
): Promise<User | null> {
  try {
    // 1. Registrar no auth do Supabase
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    });
    
    if (error) {
      if (error.message.includes("already registered")) {
        toast({
          title: "Email j√° registrado",
          description: "Este email j√° est√° sendo usado",
          variant: "destructive"
        });
      } else {
        toast({
          title: "Erro no registro",
          description: error.message,
          variant: "destructive"
        });
      }
      return null;
    }
    
    if (!data.user) {
      toast({
        title: "Erro no registro",
        description: "N√£o foi poss√≠vel criar a conta",
        variant: "destructive"
      });
      return null;
    }
    
    // 2. Criar perfil na tabela uuid
    const userId = data.user.id;
    const displayName = firstName || email.split('@')[0];
    
    const newUser = {
      id: userId,
      email: email,
      username: displayName,
      first_name: firstName,
      display_name: displayName,
      phone_number: phoneNumber,
      role: "user",
      created_at: new Date().toISOString(),
    };
    
    const { data: profile, error: profileError } = await supabase
      .from("uuid")
      .insert([newUser])
      .select()
      .single();
    
    if (profileError) {
      toast({
        title: "Erro ao criar perfil",
        description: "Conta criada, mas n√£o foi poss√≠vel salvar seus dados",
        variant: "destructive"
      });
      return null;
    }
    
    // 3. Armazenar para acesso r√°pido e fazer login autom√°tico
    localStorage.setItem('current_user', JSON.stringify(profile));
    
    // Login autom√°tico
    await supabase.auth.signInWithPassword({
      email,
      password,
    });
    
    toast({
      title: "Conta criada",
      description: "Registro conclu√≠do com sucesso!",
    });
    
    return profile as User;
  } catch (error) {
    toast({
      title: "Erro no registro",
      description: "Ocorreu um erro inesperado",
      variant: "destructive"
    });
    return null;
  }
}

/**
 * Obter usu√°rio atual
 * Vers√£o simplificada que apenas verifica a sess√£o e busca dados do perfil
 */
export async function getCurrentUser(): Promise<User | null> {
  try {
    // 1. Verificar se h√° sess√£o
    const { data } = await supabase.auth.getSession();
    
    if (!data.session) {
      return null;
    }
    
    // 2. Tentar usar dados em cache primeiro
    const cachedUser = localStorage.getItem('current_user');
    if (cachedUser) {
      return JSON.parse(cachedUser) as User;
    }
    
    // 3. Buscar da tabela se n√£o encontrou em cache
    const userId = data.session.user.id;
    const { data: profile } = await supabase
      .from("uuid")
      .select("*")
      .eq("id", userId)
      .single();
    
    if (profile) {
      localStorage.setItem('current_user', JSON.stringify(profile));
      return profile as User;
    }
    
    return null;
  } catch (error) {
    console.error("Erro ao buscar usu√°rio atual:", error);
    return null;
  }
}

/**
 * Verifica se o usu√°rio est√° autenticado
 * Vers√£o simplificada que apenas verifica a sess√£o
 */
export const isAuthenticated = async (): Promise<boolean> => {
  try {
    const { data } = await supabase.auth.getSession();
    return !!data.session;
  } catch (error) {
    return false;
  }
};

/**
 * Realiza o logout do usu√°rio
 * Vers√£o simplificada que apenas faz logout e limpa dados
 */
export const signOut = async (): Promise<boolean> => {
  try {
    // Limpar localStorage
    localStorage.removeItem('current_user');
    
    // Fazer logout no Supabase
    await supabase.auth.signOut();
    
    toast({
      title: "Logout realizado",
      description: "Voc√™ saiu da sua conta com sucesso",
    });
    
    return true;
  } catch (error) {
    toast({
      title: "Erro ao sair",
      description: "N√£o foi poss√≠vel fazer logout",
      variant: "destructive"
    });
    return false;
  }
};

/**
 * Verifica se o usu√°rio √© admin
 */
export const isAdmin = async (): Promise<boolean> => {
  const user = await getCurrentUser();
  return user?.role === 'admin';
};

/**
 * Verifica se o usu√°rio √© l√≠der ou admin
 */
export const isLeader = async (): Promise<boolean> => {
  const user = await getCurrentUser();
  return user?.role === 'leader' || user?.role === 'admin';
};

// Login com Google
export const signInWithGoogle = async () => {
  try {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: `${window.location.origin}/auth/callback`
      }
    });

    if (error) throw error;
    return data;
  } catch (error: any) {
    toast({
      title: "Erro ao fazer login com Google",
      description: error.message,
      variant: "destructive"
    });
    return null;
  }
};

// Buscar e armazenar dados do perfil do usu√°rio
const fetchAndStoreUserProfile = async (userId: string): Promise<User | null> => {
  console.log(`üîç Buscando perfil do usu√°rio ${userId}...`);
  try {
    // Buscar dados do usu√°rio no banco
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();
      
    if (error) {
      console.error(`‚ùå Erro ao buscar perfil:`, error);
      
      // Se o erro for NOT_FOUND (usu√°rio n√£o existe), vamos ver se h√° um registro auth
      if (error.code === 'PGRST116') {
        console.log(`‚ö†Ô∏è Perfil n√£o encontrado para usu√°rio ${userId}. Verificando se √© um novo usu√°rio...`);
        const { data: authUser } = await supabase.auth.getUser();
        
        if (authUser && authUser.user) {
          console.log(`üë§ Dados de autentica√ß√£o encontrados. Criando perfil para ${authUser.user.email}...`);
          
          // Criar perfil b√°sico para o usu√°rio - usando snake_case para os campos
          const newUser: User = {
            id: userId,
            email: authUser.user.email || '',
            role: 'user',
            username: authUser.user.email?.split('@')[0] || '',
            first_name: authUser.user.email?.split('@')[0] || '',
            created_at: new Date().toISOString(),
          };
          
          // Inserir na tabela de usu√°rios
          const { data: insertData, error: insertError } = await supabase
            .from('users')
            .insert(newUser)
            .select()
            .single();
            
          if (insertError) {
            console.error(`‚ùå Erro ao criar perfil:`, insertError);
            return null;
          }
          
          console.log(`‚úÖ Perfil criado com sucesso para ${newUser.email}`);
          localStorage.setItem('current_user', JSON.stringify(insertData || newUser));
          return insertData || newUser;
        }
      }
      
      return null;
    }
    
    if (data) {
      console.log(`‚úÖ Perfil encontrado para ${data.email}`);
      localStorage.setItem('current_user', JSON.stringify(data));
      return data;
    }
    
    return null;
  } catch (error) {
    console.error(`‚ùå Erro geral ao buscar perfil:`, error);
    return null;
  }
};

// Atualizar papel do usu√°rio
export const updateUserRole = async (userId: string, newRole: string) => {
  try {
    const { data: updatedUser, error } = await supabase
      .from('users')
      .update({ role: newRole, updated_at: new Date().toISOString() })
      .eq('id', userId)
      .select('id, email, username, role, display_name, bio, avatar_url, created_at, updated_at, profile_views')
      .single();

    if (error) throw error;
    return updatedUser;
  } catch (error) {
    console.error('Erro ao atualizar fun√ß√£o do usu√°rio:', error);
    throw error;
  }
};

// Atualizar perfil do usu√°rio
export const updateUserProfile = async (userId: string, userData: Partial<User>) => {
  try {
    // Converter camelCase para snake_case
    const dbData = {
      display_name: userData.display_name,
      bio: userData.bio,
      avatar_url: userData.avatar_url
    };

    const { data, error } = await supabase
      .from('users')
      .update(dbData)
      .eq('id', userId)
      .select('id, email, username, role, display_name, bio, avatar_url, created_at, updated_at, profile_views')
      .single();
    
    if (error) throw error;
    
    if (data) {
      // Converter snake_case de volta para camelCase
      const userResponse: User = {
        ...data,
        display_name: data.display_name,
        avatar_url: data.avatar_url,
        created_at: data.created_at
      };
      
      // Atualizar cache local
      localStorage.setItem('current_user', JSON.stringify(userResponse));
      
      // Emitir evento de mudan√ßa de estado
      window.dispatchEvent(new Event('auth-state-changed'));
      
      return userResponse;
    }
    
    return null;
  } catch (error: any) {
    console.error("Erro ao atualizar perfil:", error);
    throw error;
  }
};

// Obter usu√°rio por ID
export const getUserById = async (userId: string): Promise<User | null> => {
  try {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();
    
    if (error) {
      console.error("Erro ao buscar usu√°rio:", error);
      return null;
    }
    
    return data as User;
  } catch (error) {
    console.error("Erro ao buscar usu√°rio:", error);
    return null;
  }
};

export const getAllUsers = async () => {
  try {
    const { data: users, error } = await supabase
      .from('users')
      .select('id, email, username, role, display_name, bio, avatar_url, created_at, updated_at, profile_views')
      .order('created_at', { ascending: false });

    if (error) throw error;
    return users;
  } catch (error) {
    console.error('Erro ao buscar usu√°rios:', error);
    throw error;
  }
};

// Atualizar papel do usu√°rio por email
export const updateUserRoleByEmail = async (email: string, newRole: string) => {
  try {
    const { data: user, error: userError } = await supabase
      .from('users')
      .select('id')
      .eq('email', email)
      .single();
    
    if (userError || !user) {
      throw new Error('Usu√°rio n√£o encontrado');
    }
    
    const { data: updatedUser, error } = await supabase
      .from('users')
      .update({ role: newRole, updated_at: new Date().toISOString() })
      .eq('id', user.id)
      .select('id, email, username, role, display_name, bio, avatar_url, created_at, updated_at, profile_views')
      .single();

    if (error) throw error;
    return updatedUser;
  } catch (error) {
    console.error('Erro ao atualizar fun√ß√£o do usu√°rio:', error);
    throw error;
  }
};

/**
 * Limpa completamente todos os dados de autentica√ß√£o do Supabase
 * Isso inclui localStorage, sessionStorage e cookies espec√≠ficos
 */
export function clearAllAuthData(): void {
  console.log("üßπ Iniciando limpeza completa de dados de autentica√ß√£o...");
  
  // Gerar um ID √∫nico para esta opera√ß√£o de limpeza
  const cleanupId = Date.now().toString();
  
  // Garantir que o flag de logout est√° definido para evitar verifica√ß√µes durante a limpeza
  window.sessionStorage.setItem('logout_in_progress', 'true');
  window.sessionStorage.setItem('cleanup_id', cleanupId);
  
  // Desativar temporariamente os listeners de eventos do storage
  const originalAddEventListener = window.addEventListener;
  const originalDispatchEvent = window.dispatchEvent;
  
  // Flag para prevenir eventos auth-state-changed durante a limpeza
  let isCleaningAuth = true;
  
  try {
    // Substituir temporariamente o dispatchEvent para suprimir eventos de storage e auth
    window.dispatchEvent = function(event) {
      if (event.type === 'storage' || event.type === 'auth-state-changed') {
        console.log(`üõë Evento de ${event.type} suprimido para evitar loops`);
        return true;
      }
      return originalDispatchEvent.apply(this, [event]);
    };
    
    // 1. Limpar localStorage
    console.log("üßπ Limpando localStorage...");
    const keysToRemove = [
      'current_user',
      'supabase.auth.token',
      'sb-access-token',
      'sb-refresh-token',
      'supabase.auth.data',
      'sb-provider-token',
      'supabase-auth-token',
      'sb-phplnehnmnqywqzzzytg-auth-token',
      'sb:token',
      'sb:token:phplnehnmnqywqzzzytg', // Incluir projeto espec√≠fico
      'supabase.auth.expires_at',
      'supabase.auth.token.expiresAt',
      // Adicionar qualquer outro padr√£o poss√≠vel
    ];
    
    // Remover chaves espec√≠ficas
    keysToRemove.forEach(key => {
      if (localStorage.getItem(key)) {
        console.log(`   üóëÔ∏è Removendo ${key} do localStorage`);
        localStorage.removeItem(key);
      }
    });
    
    // Buscar e remover todas as chaves que come√ßam com 'sb-' ou 'supabase'
    const allLocalStorageKeys = Object.keys(localStorage);
    allLocalStorageKeys.forEach(key => {
      if (key.startsWith('sb-') || key.startsWith('supabase')) {
        console.log(`   üóëÔ∏è Removendo chave din√¢mica ${key} do localStorage`);
        localStorage.removeItem(key);
      }
    });
    
    // 2. Limpar sessionStorage
    console.log("üßπ Limpando sessionStorage...");
    const sessionKeysToRemove = [
      'supabase.auth.token',
      'sb-access-token',
      'sb-refresh-token',
      'sb-phplnehnmnqywqzzzytg-auth-token',
      'sb:token',
      'supabase.auth.expires_at',
    ];
    
    // Remover chaves espec√≠ficas
    sessionKeysToRemove.forEach(key => {
      if (sessionStorage.getItem(key)) {
        console.log(`   üóëÔ∏è Removendo ${key} do sessionStorage`);
        sessionStorage.removeItem(key);
      }
    });
    
    // Buscar e remover todas as chaves que come√ßam com 'sb-' ou 'supabase'
    const allSessionStorageKeys = Object.keys(sessionStorage);
    allSessionStorageKeys.forEach(key => {
      if (key.startsWith('sb-') || key.startsWith('supabase')) {
        console.log(`   üóëÔ∏è Removendo chave din√¢mica ${key} do sessionStorage`);
        sessionStorage.removeItem(key);
      }
    });
    
    // 3. Limpar cookies espec√≠ficos do Supabase
    console.log("üßπ Limpando cookies relacionados ao Supabase...");
    const cookiesToRemove = [
      'sb-access-token',
      'sb-refresh-token',
      'supabase-auth-token',
      '__stripe_mid',
      '__stripe_sid',
      'sb:token',
      'sb-phplnehnmnqywqzzzytg-auth-token',
      'sb-provider-token',
    ];
    
    cookiesToRemove.forEach(cookieName => {
      document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
      console.log(`   üóëÔ∏è Removendo cookie ${cookieName}`);
    });
    
    // 4. Tentar limpar a sess√£o atual do Supabase
    console.log("üßπ Tentando limpar a sess√£o do Supabase Auth (sem valida√ß√£o)...");
    try {
      // Evitar o uso de promessas para n√£o causar loops ass√≠ncronos
      // Em vez disso, simplesmente tentar fazer o signOut sem esperar
      supabase.auth.signOut();
    } catch (error) {
      console.error("‚ö†Ô∏è Erro ao tentar limpar sess√£o do Supabase:", error);
    }
    
    console.log("‚úÖ Limpeza completa de dados de autentica√ß√£o finalizada");
  } finally {
    // Restaurar o comportamento original ap√≥s a conclus√£o
    window.dispatchEvent = originalDispatchEvent;
    
    // Verificar se ainda somos o processo de limpeza ativo
    // (para evitar remover a flag se outra limpeza foi iniciada)
    if (window.sessionStorage.getItem('cleanup_id') === cleanupId) {
      // Definir um temporizador para evitar verifica√ß√µes imediatas de autentica√ß√£o
      // Mas com um tempo menor para n√£o bloquear o usu√°rio por muito tempo
      setTimeout(() => {
        if (window.sessionStorage.getItem('cleanup_id') === cleanupId) {
          window.sessionStorage.removeItem('logout_in_progress');
          window.sessionStorage.removeItem('cleanup_id');
          console.log("‚úÖ Per√≠odo de resfriamento de autentica√ß√£o finalizado");
        } else {
          console.log("‚ö†Ô∏è Outra limpeza foi iniciada, mantendo flag de logout");
        }
      }, 1000);
    } else {
      console.log("‚ö†Ô∏è Outra limpeza foi iniciada, mantendo flag de logout");
    }
  }
} 